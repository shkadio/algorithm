/*
例题3-4 猜数字游戏的提示（Master-Mind Hints, UVa 340）
实现一个经典“猜数字”游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B）。
输入包含多组数据。每组输入第一行为序列长度 n，第二行是答案序列，接下来是若干猜测序列。猜测序列全0时该组数据结束。n=0 时输入结束。

样例输入：
4
1 3 5 5
1 1 2 3
4 3 3 5
6 5 5 1
6 1 3 5
1 3 5 5
0 0 0 0
10
1 2 2 2 4 5 6 6 6 9
1 2 3 4 5 6 7 8 9 1
1 1 2 2 3 3 4 4 5 5
1 2 1 3 1 5 1 6 1 9
1 2 2 5 5 5 6 6 6 7
0 0 0 0 0 0 0 0 0 0
0

样例输出：
Game 1:
    (1,1)
    (2,0)
    (1,2)
    (1,2)
    (4,0)
Game 2:
    (2,4)
    (3,2)
    (5,0)
    (7,0)
*/


//对于A:按照索引一个一个比较即可
//对于B:如果当前数字在答案序列中且位置不对，记为1
// 统计所有的这样的数字，存在数组中，并与A比较，如果存在A数组中，减去该数字
// 复杂了

// 先统计A:如果存在标记为A的数字，将其从答案序列中删除
// 再计算B：索引相同，数字不同，在序列中找，找到+1

#include <stdio.h>
#define maxn 100
int a[maxn],b[maxn];
int main(){
    int n,count,A = 0,B = 0;
    while(scanf("%d",&n) == 1){
        for(int i = 0;i<n;i++){
            scanf("%d",&a[i]);
            if(a[i] == 0) count++;
        }
        if(count == n) continue;    // 如果是n个0,该组数据结束
        int x = 0,arr[maxn];
        while(scanf("%d",&b[x]) == 1){
            // 统计A的个数
            if(a[x] == b[x]) {
                A++;
                arr[x] = 0;
            }
            else arr[x] = a[x];
            x++;

        }

    }
    return 0;
}