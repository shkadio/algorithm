/*
例题3-4 猜数字游戏的提示（Master-Mind Hints, UVa 340）
实现一个经典“猜数字”游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B）。
输入包含多组数据。每组输入第一行为序列长度 n，第二行是答案序列，接下来是若干猜测序列。猜测序列全0时该组数据结束。n=0 时输入结束。

样例输入：
4
1 3 5 5
1 1 2 3
4 3 3 5
6 5 5 1
6 1 3 5
1 3 5 5
0 0 0 0
10
1 2 2 2 4 5 6 6 6 9
1 2 3 4 5 6 7 8 9 1
1 1 2 2 3 3 4 4 5 5
1 2 1 3 1 5 1 6 1 9
1 2 2 5 5 5 6 6 6 7
0 0 0 0 0 0 0 0 0 0
0

样例输出：
Game 1:
    (1,1)
    (2,0)
    (1,2)
    (1,2)
    (4,0)
Game 2:
    (2,4)
    (3,2)
    (5,0)
    (7,0)
*/

// 对于A:按照索引一个一个比较即可
// 对于B:如果当前数字在答案序列中且位置不对，记为1
//  统计所有的这样的数字，存在数组中，并与A比较，如果存在A数组中，减去该数字
//  复杂了

// 先统计A:如果存在标记为A的数字，将其从答案序列中删除
// 再计算B：索引相同，数字不同，在序列中找，找到+1

#include <stdio.h>
#define maxn 100
int a[maxn], b[maxn];
int main(){
    int n, kase = 0;
    while (scanf("%d", &n) == 1 && n){
        printf("Game %d:\n", ++kase);
        // 读入答案序列
        for (int i = 0; i < n; i++)     scanf("%d", &a[i]);
        for (;;){
            int i = 0, A = 0, B = 0;
            // 读入猜测序列
            for (int i = 0; i < n; i++){
                scanf("%d", &b[i]);
                if (b[i] == a[i])   A++;
            }
            if (b[0] == 0)  break;
            for (int i = 1; i <= 9; i++){
                int c1 = 0, c2 = 0; // 统计i在答案序列和猜测序列中出现的次数
                for (int j = 0; j < n; j++){
                    if (a[j] == i)  c1++;
                    if (b[j] == i)  c2++;
                }
                if (c1 > c2)    B += c2; else    B += c1;
            }
            printf("\t(%d,%d)\n", A, B-A);
        }
    }
    return 0;
}